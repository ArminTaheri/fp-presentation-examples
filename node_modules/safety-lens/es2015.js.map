{"version":3,"sources":["es2015.js.flow"],"names":[],"mappings":";;;;;;;;;AAEA;;;;AAOA,SAAS,KAAT,CAAoB,GAApB,EAA6D;AAC3D,SAAO;AAAA,WAAK,UAAC,IAAD,EAAO,KAAP,EAAiB;AAC3B,UAAI,OAAO,MAAM,GAAN,CAAP,KAAsB,WAA1B,EAAuC;AACrC,eAAO,EAAE,IAAF,EAAQ,MAAM,GAAN,CAAR,EAAoB,GAApB,CAAwB;AAAA,iBAC7B,MAAM,GAAN,CAAU,UAAC,CAAD,EAAI,CAAJ;AAAA,mBAAU,MAAM,GAAN,GAAY,YAAZ,GAA2B,CAArC;AAAA,WAAV,CAD6B;AAAA,SAAxB,CAAP;AAGD,OAJD,MAKK;AACH,eAAO,KAAK,KAAL,CAAP;AACD;AACF,KATM;AAAA,GAAP;AAUD;;;;;;;;AASD,SAAS,IAAT,CAAqC,IAArC,EAA+E;AAC7E,SAAQ,IAAI,IAAJ,CAAR,CA/BF;AAgCC;;;;;;;;AAQD,SAAS,GAAT,CAAkB,IAAlB,EAA4F;AAC1F,SAAO,gBACL;AAAA,WAAO,IAAI,IAAJ,CAAP;AAAA,GADK,EAEL,UAAC,GAAD,EAAM,GAAN,EAAc;AACZ,QAAM,SAAS,EAAf;AADY;AAAA;AAAA;;AAAA;AAEZ,2BAAgB,OAAO,IAAP,CAAY,GAAZ,CAAhB,8HAAkC;AAAA,YAAvB,CAAuB;;AAChC,YAAI,MAAM,IAAV,EAAgB;AAAE,iBAAO,CAAP,IAAY,IAAI,CAAJ,CAAZ;AAAoB;AACvC;AAJW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKZ,QAAI,OAAO,GAAP,KAAe,WAAnB,EAAgC;AAC9B,aAAO,IAAP,IAAe,GAAf;AACD;AACD,WAAO,MAAP;AACD,GAXI,CAAP;AAaD;;;;;AAMD,SAAS,EAAT,CAEC,CAFD,EAEoE;AAClE,SAAO,UAAC,IAAD;AAAA;;AAAA,QAAQ,CAAR;AAAA,QAAU,CAAV;AAAA,WACL,EAAE,IAAF,EAAQ,CAAR,EAAW,GAAX,CAAe;AAAA,aAAK,CAAC,CAAD,EAAG,CAAH,CAAL;AAAA,KAAf,CADK;AAAA,GAAP;AAGD;;;AAGD,SAAS,EAAT,CAEC,CAFD,EAEoE;AAClE,SAAO,UAAC,IAAD;AAAA;;AAAA,QAAQ,CAAR;AAAA,QAAU,CAAV;AAAA,WACL,EAAE,IAAF,EAAQ,CAAR,EAAW,GAAX,CAAe;AAAA,aAAK,CAAC,CAAD,EAAG,CAAH,CAAL;AAAA,KAAf,CADK;AAAA,GAAP;AAGD;;;;;AAMD,SAAS,OAAT,CACC,CADD,EACkG;AAChG,SAAO,UAAC,IAAD,EAAO,OAAP;AAAA,WAAmB,KAAK,QAAQ,IAAR,CAAa;AAAA,aAAK,EAAE,IAAF,EAAQ,CAAR,EAAW,KAAhB;AAAA,KAAb,CAAL,CAAnB;AAAA,GAAP;AACD;;;AAGD,SAAS,OAAT,CACC,CADD,EACkG;AAChG,SAAO,UAAC,IAAD,EAAO,OAAP;AAAA,WAAmB,KAAK,QAAQ,IAAR,WAAiB;AAAA,aAAK,QAAQ,MAAR,CAAe,EAAE,IAAF,EAAQ,CAAR,EAAW,KAA1B,CAAL;AAAA,KAAjB,CAAL,CAAnB;AAAA,GAAP;AACD;;QAGC,KA7FF,GA6FE,KA7FF;QA8FE,GA9FF,GA8FE,GA9FF;QA+FE,IA/FF,GA+FE,IA/FF;QAgGE,EAhGF,GAgGE,EAhGF;QAiGE,EAjGF,GAiGE,EAjGF;QAkGE,OAlGF,GAkGE,OAlGF;QAmGE,OAnGF,GAmGE,OAnGF","file":"es2015.js","sourcesContent":["/* @flow */\n\nimport { id, lens } from './lens'\n\nimport type { Identity, Lens, Lens_, Pure_, Traversal } from './lens'\nimport type { Functor, Pure } from './lib/fantasy-land'\n\n/* arrays */\n\nfunction index<A,B>(idx: number): Traversal<A[],(A|B[]),A,B> {\n  return f => (pure, array) => {\n    if (typeof array[idx] !== 'undefined') {\n      return f(pure, array[idx]).map(updatedValue => (\n        array.map((v, i) => i === idx ? updatedValue : v)\n      ))\n    }\n    else {\n      return pure(array)\n    }\n  }\n}\n\n\n/* objects */\n\n/*\n * Access a property in an object. Flow will emit an error if the named property\n * is not a member of the target object type.\n */\nfunction prop<S:Object,T:Object,A,B>(name: $Keys<S> | $Keys<T>): Lens<S,T,A,B> {\n  return (key(name): any)  // cast from `Traversal` to `Lens`\n}\n\n/*\n * Access a property in an object. With this version, flow will not check if the\n * property exists in the target type. Use `key` instead of `prop` when the\n * target is used as a map (as opposed to a record), or when an undefined result\n * is acceptable.\n */\nfunction key<A,B>(name: string): Traversal<{ [key: string]: A },{ [key: string]: A|B },A,B> {\n  return lens(\n    obj => obj[name],\n    (obj, val) => {\n      const newObj = {}\n      for (const k of Object.keys(obj)) {\n        if (k !== name) { newObj[k] = obj[k] }\n      }\n      if (typeof val !== 'undefined') {\n        newObj[name] = val\n      }\n      return newObj\n    }\n  )\n}\n\n\n/* tuples */\n\n// Lens<[A,B],[C,B],A,C>\nfunction _1\n<A,B,C, FB: Functor<C>, FT: Functor<[C,B]>>\n(f: (pure: Pure_, val: A) => FB): ((pure: Pure_, obj: [A,B]) => FT) {\n  return (pure, [a,b]) => (\n    f(pure, a).map(c => [c,b])\n  )\n}\n\n// Lens<[A,B],[A,C],B,C>\nfunction _2\n<A,B,C, FB: Functor<C>, FT: Functor<[A,C]>>\n(f: (pure: Pure_, val: B) => FB): ((pure: Pure_, obj: [A,B]) => FT) {\n  return (pure, [a,b]) => (\n    f(pure, b).map(c => [a,c])\n  )\n}\n\n\n/* Promise */\n\n// Setting<Promise<A>,Promise<B>,A,B>\nfunction success<A,B>\n(f: (pure: Pure, val: A) => Identity<B>): ((pure: Pure, obj: Promise<A>) => Identity<Promise<B>>) {\n  return (pure, promise) => pure(promise.then(a => f(pure, a).value))\n}\n\n// Setting<Promise<X>,Promise<X>,A,B>\nfunction failure<A,B>\n(f: (pure: Pure, val: A) => Identity<B>): ((pure: Pure, obj: Promise<A>) => Identity<Promise<B>>) {\n  return (pure, promise) => pure(promise.then(id, a => Promise.reject(f(pure, a).value)))\n}\n\nexport {\n  index,\n  key,\n  prop,\n  _1,\n  _2,\n  success,\n  failure,\n}\n"]}