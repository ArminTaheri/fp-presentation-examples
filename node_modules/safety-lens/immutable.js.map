{"version":3,"sources":["immutable.js.flow"],"names":[],"mappings":"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","file":"immutable.js","sourcesContent":["/* @flow */\n\nimport { foldrOf, lens } from './lens'\nimport { ap } from './lib/Applicative'\nimport { Collection, List, Map, Record, Set, Stack } from 'immutable'\n\nimport type { Iterable } from 'immutable'\nimport type { Apply, Pure } from './lib/fantasy-land'\nimport type { Endo, Fold, Lens_, Traversal_ } from './lens'\n\nexport {\n  contains,\n  field,\n  index,\n  index as key,\n  toListOf,\n  toStackOf,\n  traverse,\n}\n\n/* lenses */\n\nfunction field<S:Object,A>(name: $Keys<S>): Lens_<Record<S>,A> {\n  return lens(\n    obj => obj.get((name:any)),\n    (obj, val) => obj.set((name:any), val)\n  )\n}\n\nfunction contains<V>(val: V): Lens_<Set<V>, boolean> {\n  return lens(\n    obj => obj.has(val),\n    (obj, b) => b ? obj.add(val) : obj.remove(val)\n  )\n}\n\n\n/* traversals */\n\nfunction index<K,V, S:Iterable<K,V>>(idx: K): Traversal_<S,V> {\n  return f => (pure, obj) => {\n    if (obj.has(idx)) {\n      const value = (obj.get(idx): any)  // cast, because idx is guaranteed to be present\n      return f(pure, value).map(updatedValue => {\n        // Optimize update for certain types\n        if (typeof obj.set === 'function') {\n          return obj.set(idx, updatedValue)\n        }\n        else {\n          // This works for any Iterable, but might not give the most efficient update.\n          return (obj:any).map((v, k) => k === idx ? updatedValue : v)\n        }\n      })\n    }\n    else {\n      return pure(obj)\n    }\n  }\n}\n\n/*\n * You can use the `traverse` function to get a `Traversal` from any\n * `Traversable` value.\n *\n * A `Traversal` is a specialized lens: it can act as a setter,\n * but cannot be used as a getter with the `get` function.\n *\n * For example:\n *\n *     var xs = List([1,2,3])\n *\n *     over(traverse, x => x * 2, xs)\n *\n *     assert(is( xs, List([2,4,6]))\n *\n */\nfunction traverse<A,K,B, FB: Apply<B>, TB: Collection<K,B>, FTB: Apply<TB>>(\n  f: (pure: Pure, _: A) => FB\n): (pure: Pure, obj: Collection<K,A>) => FTB {\n  return (pure, obj) => {\n    if (obj instanceof Collection.Keyed) {\n      return traverseKeyedCollection((f:any))(pure, obj)  // TODO: get rid of type cast\n    }\n    else if (obj instanceof Collection.Indexed) {\n      return traverseIndexedCollection((f:any))(pure, obj)\n    }\n    else if (obj instanceof Collection.Set) {\n      return traverseSetCollection((f:any))(pure, obj)\n    }\n    else {\n      throw new TypeError(\"No `traverse` implementation for \"+ nameOfType(obj))\n    }\n  }\n}\n\nfunction traverseIndexedCollection<A,B, TB: Collection.Indexed<B>, FTB: Apply<TB>>(\n  f: <FB: Apply<B>>(pure: Pure, _: A) => FB\n): (pure: Pure, obj: Collection.Indexed<A>) => FTB {\n  return (pure, obj) => {\n    var cons = indexedCons(obj)\n    var emptyColl = obj.take(0)\n    return obj.reduceRight((ys, x) => f(pure, x).map(cons).ap(ys), pure(emptyColl))\n  }\n}\n\nfunction traverseSetCollection<A,B, TB: Collection.Set<B>, FTB: Apply<TB>>(\n  f: <FB: Apply<B>>(pure: Pure, _: A) => FB\n): (pure: Pure, obj: Collection.Set<A>) => FTB {\n  return (pure, obj) => {\n    var cons = setCons(obj)\n    var emptyColl = obj.take(0)\n    return obj.reduceRight((ys, x) => f(pure, x).map(cons).ap(ys), pure(emptyColl))\n  }\n}\n\nfunction traverseKeyedCollection<A,K,B, TB: Collection.Keyed<K,B>, FTB: Apply<TB>>(\n  f: <FB: Apply<B>>(pure: Pure, _: A) => FB\n): (pure: Pure, obj: Collection.Keyed<K,A>) => FTB {\n  return (pure, obj) => {\n    var cons = keyedCons(obj)\n    var emptyColl = obj.take(0)\n    return obj.reduceRight(\n      (ys, x, key) => f(pure, x).map(cons).ap(pure(key)).ap(ys),\n      pure(emptyColl)\n    )\n  }\n}\n\nfunction indexedCons<A,S: Collection.Indexed<A>>(coll: S): (val: A) => (coll: S) => S {\n  return val => coll => {\n    if (coll instanceof List) {\n      return coll.unshift(val)\n    }\n    else if (coll instanceof Stack) {\n      return coll.unshift(val)\n    }\n    else {\n      const emptyColl = (coll:any).take(0)\n      return emptyColl.concat(val).concat(coll)\n    }\n  }\n}\n\nfunction setCons<A,S: Collection.Set<A>>(coll: S): (val: A) => (coll: S) => S {\n  return val => coll => {\n    if (coll instanceof Set) {\n      return coll.add(val)\n    }\n    else {\n      const emptyColl = (coll:any).take(0)\n      return emptyColl.concat(val).concat(coll)\n    }\n  }\n}\n\nfunction keyedCons<A,K,S: Collection.Keyed<K,A>>(coll: S): (val: A) => (key: K) => (coll: S) => S {\n  return val => key => coll => {\n    if (coll instanceof Map) {\n      return coll.set(key, val)\n    }\n    else {\n      var emptyColl = coll.take(0)\n      return emptyColl.concat([[key,val]]).concat(coll)\n    }\n  }\n}\n\nfunction nameOfType(obj: Object) {\n  return obj && obj.constructor && obj.constructor.name ? obj.constructor.name : String(obj)\n}\n\n\n/* traversing */\n\nfunction toListOf<S,A>(l: Fold<Endo<List<A>>,S,A>, obj: S): List<A> {\n  return foldrOf(l, (x, xs) => xs.unshift(x), List(), obj)\n}\n\n/*\n * Constructing a stack using foldr might be more efficient than constructing\n * a list, since Immutable's Stack is implemented as a linked list, while List\n * is implemented as a tree-backed vector.\n */\nfunction toStackOf<S,A>(l: Fold<Endo<Stack<A>>,S,A>, obj: S): Stack<A> {\n  return foldrOf(l, (x, xs) => xs.unshift(x), Stack(), obj)\n}\n"]}