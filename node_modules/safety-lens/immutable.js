'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverse = exports.toStackOf = exports.toListOf = exports.key = exports.index = exports.field = exports.contains = undefined;

var _lens = require('./lens');

var _Applicative = require('./lib/Applicative');

var _immutable = require('immutable');

exports.contains = contains;
exports.field = field;
exports.index = index;
exports.key = index;
exports.toListOf = toListOf;
exports.toStackOf = toStackOf;
exports.traverse = traverse;

/* lenses */

function field(name) {
  return (0, _lens.lens)(function (obj) {
    return obj.get(name);
  }, function (obj, val) {
    return obj.set(name, val);
  });
}

function contains(val) {
  return (0, _lens.lens)(function (obj) {
    return obj.has(val);
  }, function (obj, b) {
    return b ? obj.add(val) : obj.remove(val);
  });
}

/* traversals */

function index(idx) {
  return function (f) {
    return function (pure, obj) {
      if (obj.has(idx)) {
        var value = obj.get(idx); // cast, because idx is guaranteed to be present
        return f(pure, value).map(function (updatedValue) {
          // Optimize update for certain types
          if (typeof obj.set === 'function') {
            return obj.set(idx, updatedValue);
          } else {
            // This works for any Iterable, but might not give the most efficient update.
            return obj.map(function (v, k) {
              return k === idx ? updatedValue : v;
            });
          }
        });
      } else {
        return pure(obj);
      }
    };
  };
}

/*
 * You can use the `traverse` function to get a `Traversal` from any
 * `Traversable` value.
 *
 * A `Traversal` is a specialized lens: it can act as a setter,
 * but cannot be used as a getter with the `get` function.
 *
 * For example:
 *
 *     var xs = List([1,2,3])
 *
 *     over(traverse, x => x * 2, xs)
 *
 *     assert(is( xs, List([2,4,6]))
 *
 */
function traverse(f) {
  return function (pure, obj) {
    if (obj instanceof _immutable.Collection.Keyed) {
      return traverseKeyedCollection(f)(pure, obj); // TODO: get rid of type cast
    } else if (obj instanceof _immutable.Collection.Indexed) {
        return traverseIndexedCollection(f)(pure, obj);
      } else if (obj instanceof _immutable.Collection.Set) {
        return traverseSetCollection(f)(pure, obj);
      } else {
        throw new TypeError("No `traverse` implementation for " + nameOfType(obj));
      }
  };
}

function traverseIndexedCollection(f) {
  return function (pure, obj) {
    var cons = indexedCons(obj);
    var emptyColl = obj.take(0);
    return obj.reduceRight(function (ys, x) {
      return f(pure, x).map(cons).ap(ys);
    }, pure(emptyColl));
  };
}

function traverseSetCollection(f) {
  return function (pure, obj) {
    var cons = setCons(obj);
    var emptyColl = obj.take(0);
    return obj.reduceRight(function (ys, x) {
      return f(pure, x).map(cons).ap(ys);
    }, pure(emptyColl));
  };
}

function traverseKeyedCollection(f) {
  return function (pure, obj) {
    var cons = keyedCons(obj);
    var emptyColl = obj.take(0);
    return obj.reduceRight(function (ys, x, key) {
      return f(pure, x).map(cons).ap(pure(key)).ap(ys);
    }, pure(emptyColl));
  };
}

function indexedCons(coll) {
  return function (val) {
    return function (coll) {
      if (coll instanceof _immutable.List) {
        return coll.unshift(val);
      } else if (coll instanceof _immutable.Stack) {
        return coll.unshift(val);
      } else {
        var emptyColl = coll.take(0);
        return emptyColl.concat(val).concat(coll);
      }
    };
  };
}

function setCons(coll) {
  return function (val) {
    return function (coll) {
      if (coll instanceof _immutable.Set) {
        return coll.add(val);
      } else {
        var emptyColl = coll.take(0);
        return emptyColl.concat(val).concat(coll);
      }
    };
  };
}

function keyedCons(coll) {
  return function (val) {
    return function (key) {
      return function (coll) {
        if (coll instanceof _immutable.Map) {
          return coll.set(key, val);
        } else {
          var emptyColl = coll.take(0);
          return emptyColl.concat([[key, val]]).concat(coll);
        }
      };
    };
  };
}

function nameOfType(obj) {
  return obj && obj.constructor && obj.constructor.name ? obj.constructor.name : String(obj);
}

/* traversing */

function toListOf(l, obj) {
  return (0, _lens.foldrOf)(l, function (x, xs) {
    return xs.unshift(x);
  }, (0, _immutable.List)(), obj);
}

/*
 * Constructing a stack using foldr might be more efficient than constructing
 * a list, since Immutable's Stack is implemented as a linked list, while List
 * is implemented as a tree-backed vector.
 */
function toStackOf(l, obj) {
  return (0, _lens.foldrOf)(l, function (x, xs) {
    return xs.unshift(x);
  }, (0, _immutable.Stack)(), obj);
}

//# sourceMappingURL=immutable.js.map