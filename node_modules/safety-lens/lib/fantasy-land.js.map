{"version":3,"sources":["fantasy-land.js.flow"],"names":[],"mappings":";;;;;;;;;;;;;;QAUE,EAXF,GAWE,EAXF;QAYE,MAZF,GAYE,MAZF;QAaE,KAbF,GAaE,KAbF;QAcE,QAdF,GAcE,QAdF;QAeE,QAfF,GAeE,QAfF;;;AAyCA,SAAS,EAAT,CAAiB,CAAjB,EAAwC,CAAxC,EAA+D;AAC7D,SAAO,EAAE,EAAF,CAAK,CAAL,CAAP;AACD;;AAED,SAAS,MAAT,CAA2B,CAA3B,EAAiC,CAAjC,EAA0C;AACxC,SAAO,EAAE,MAAF,CAAS,CAAT,CAAP;AACD;;AAED,SAAS,KAAT,CAA0B,CAA1B,EAAmC;AACjC,SAAO,EAAE,KAAF,EAAP;AACD;;AAED,SAAS,QAAT,CACE,IADF,EAEE,CAFF,EAGM;AACJ,SAAO,EAAE,QAAF,CAAW,IAAX,CAAP;AACD;;AAED,SAAS,QAAT,CACE,IADF,EAEE,CAFF,EAGE,CAHF,EAIO;AACL,SAAO,SAAS,IAAT,EAAe,EAAE,GAAF,CAAM,CAAN,CAAf,CAAP;AACD","file":"fantasy-land.js","sourcesContent":["/*\n * Algebraic interfaces\n *\n * For information on algebraic interfaces (e.g., `Functor`), see\n * https://github.com/fantasyland/fantasy-land\n *\n * @flow\n */\n\nexport {\n  ap,\n  concat,\n  empty,\n  sequence,\n  traverse,\n}\n\nexport interface Monoid {\n  concat<M: Monoid>(other: Monoid): M,\n  empty<M: Monoid>(): M,\n}\n\nexport interface Functor<A> {\n  map<B, FB: Functor<B>>(f: (val: A) => B): FB\n}\n\nexport type Pure = <T, FT: Apply<T>>(_: T) => FT\n\nexport interface Apply<F> extends Functor<F> {\n  ap<A,B, FB: Apply<B>>(x: $Subtype<Apply<A>>): FB\n}\n\nexport interface Foldable<A> {\n  reduce<B>(f: (acc: B, val: A) => B, init: B): B\n}\n\nexport interface Traversable<A> extends Functor<A> {\n  sequence<TA: Traversable<A>, FA: Apply<TA>>(pure: Pure): FA\n}\n\nfunction ap<A,B>(f: Apply<(_: A) => B>, x: Apply<A>): Apply<B> {\n  return f.ap(x)\n}\n\nfunction concat<M: Monoid>(x: M, y: M): M {\n  return x.concat(y)\n}\n\nfunction empty<M: Monoid>(x: M): M {\n  return x.empty()\n}\n\nfunction sequence<A, FA: Apply<Traversable<A>>>(\n  pure: <T, FT: Apply<T>>(_: T) => FT,\n  t: Traversable<Apply<A>>\n): FA {\n  return t.sequence(pure)\n}\n\nfunction traverse<A,B, FTB: Apply<Traversable<B>>>(\n  pure: <T, FT: Apply<T>>(_: T) => FT,\n  f: <FB: Apply<B>>(_: A) => FB,\n  t: Traversable<A>\n): FTB {\n  return sequence(pure, t.map(f))\n}\n"]}