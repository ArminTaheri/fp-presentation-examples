'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.failure = exports.success = exports._2 = exports._1 = exports.prop = exports.key = exports.index = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _lens = require('./lens');

/* arrays */

function index(idx) {
  return function (f) {
    return function (pure, array) {
      if (typeof array[idx] !== 'undefined') {
        return f(pure, array[idx]).map(function (updatedValue) {
          return array.map(function (v, i) {
            return i === idx ? updatedValue : v;
          });
        });
      } else {
        return pure(array);
      }
    };
  };
}

/* objects */

/*
 * Access a property in an object. Flow will emit an error if the named property
 * is not a member of the target object type.
 */
function prop(name) {
  return key(name); // cast from `Traversal` to `Lens`
}

/*
 * Access a property in an object. With this version, flow will not check if the
 * property exists in the target type. Use `key` instead of `prop` when the
 * target is used as a map (as opposed to a record), or when an undefined result
 * is acceptable.
 */
function key(name) {
  return (0, _lens.lens)(function (obj) {
    return obj[name];
  }, function (obj, val) {
    var newObj = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var k = _step.value;

        if (k !== name) {
          newObj[k] = obj[k];
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (typeof val !== 'undefined') {
      newObj[name] = val;
    }
    return newObj;
  });
}

/* tuples */

// Lens<[A,B],[C,B],A,C>
function _1(f) {
  return function (pure, _ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var a = _ref2[0];
    var b = _ref2[1];
    return f(pure, a).map(function (c) {
      return [c, b];
    });
  };
}

// Lens<[A,B],[A,C],B,C>
function _2(f) {
  return function (pure, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2);

    var a = _ref4[0];
    var b = _ref4[1];
    return f(pure, b).map(function (c) {
      return [a, c];
    });
  };
}

/* Promise */

// Setting<Promise<A>,Promise<B>,A,B>
function success(f) {
  return function (pure, promise) {
    return pure(promise.then(function (a) {
      return f(pure, a).value;
    }));
  };
}

// Setting<Promise<X>,Promise<X>,A,B>
function failure(f) {
  return function (pure, promise) {
    return pure(promise.then(_lens.id, function (a) {
      return Promise.reject(f(pure, a).value);
    }));
  };
}

exports.index = index;
exports.key = key;
exports.prop = prop;
exports._1 = _1;
exports._2 = _2;
exports.success = success;
exports.failure = failure;

//# sourceMappingURL=es2015.js.map