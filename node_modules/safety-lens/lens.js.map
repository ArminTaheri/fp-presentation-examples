{"version":3,"sources":["lens.js.flow"],"names":[],"mappings":"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","file":"lens.js","sourcesContent":["/* @flow */\n\nimport { Just, just, nothing } from './lib/Maybe'\n\nimport type { Apply, Functor, Monoid, Pure, Traversable } from './lib/fantasy-land'\nimport type { Maybe } from './lib/Maybe'\n\n/* Types */\n\nexport type Lens<S,T,A,B> =\n  <FB: Functor<B>, FT: Functor<T>>\n  (f: (pure: Pure_, val: A) => FB) => ((pure: Pure_, obj: S) => FT)\n\nexport type Lens_<S,A> = Lens<S,S,A,A>\n\nexport type Getting<R,S,A> =\n  <FA: Const<R,A>, FS: Const<R,S>>\n  (f: (pure: Pure_, val: A) => FA) => ((pure: Pure_, obj: S) => FS)\n\nexport type Setting<S,T,A,B> =\n  (f: (pure: Pure, val: A) => Identity<B>) => ((pure: Pure, obj: S) => Identity<T>)\n\nexport type Getter<S,A> =\n  <FA: Contravariant<A> & Functor<A>, FS: Contravariant<S> & Functor<S>>\n  (f: (pure: Pure_, val: A) => FA) => ((pure: Pure_, obj: S) => FS)\n\nexport type Setter<S,T,A,B> =\n  <FB: Settable<B>, FT: Settable<T>>\n  (f: (pure: Pure, val: A) => FB) => ((pure: Pure, obj: S) => FT)\n\nexport type Setter_<S,A> = Setter<S,S,A,A>\n\nexport type Traversal<S,T,A,B> =\n  <FB: Apply<B>, FT: Apply<T>>\n  (f: (pure: Pure, val: A) => FB) => ((pure: Pure, obj: S) => FT)\n\nexport type Traversal_<S,A> = Traversal<S,S,A,A>\n\nexport type Fold<R,S,A> =\n  (f: (pure: Pure, val: A) => ApplyConst<R,A>) => ((pure: Pure, obj: S) => ApplyConst<R,S>)\n\n\n/*\n * Supporting interfaces\n */\n\n// `Pure_` is \"pure\" for functors - will not be invoked unless further\n// constrained to `Pure`\nexport type Pure_ = Function\n\ntype Contravariant<A> = {\n  contramap<B, FB: Contravariant<B>>(f: (_: B) => A): FB\n}\n\nexport type Settable<A> = Apply<A> & Traversable<A>\n\n\n\n/*\n * Algebraic implementations\n */\n\nclass Const<R,A> {\n  value: R;\n  constructor(value: R) {\n    this.value = value\n  }\n  map<B, FB: Const<R,B>>(f: (_: A) => B): FB {\n    return (new Const(this.value): any)\n  }\n  contramap<B, FB: Const<R,B>>(f: (_: B) => A): FB {\n    return (new Const(this.value): any)\n  }\n}\n\nclass ApplyConst<R:Monoid,A> extends Const<R,A> {\n  ap<T,U, FU: ApplyConst<R,U>>(x: ApplyConst<R,T>): FU {\n    return (new ApplyConst(this.value.concat(x.value)): any)\n  }\n  map<B, FB: ApplyConst<R,B>>(f: (_: A) => B): FB {\n    return (new ApplyConst(this.value): any)\n  }\n  contramap<B, FB: ApplyConst<R,B>>(f: (_: B) => A): FB {\n    return (new ApplyConst(this.value): any)\n  }\n}\n\nclass Identity<A> {\n  value: A;\n  constructor(value: A) {\n    this.value = value\n  }\n  map<B, FB: Identity<B>>(f: (_: A) => B): FB {\n    return (new Identity(f(this.value)): any)\n  }\n  ap<T,U, FU: Identity<U>>(x: Identity<T>): FU {\n    var f: any = this.value\n    return (new Identity(f(x.value)): any)\n  }\n  sequence<TA: Traversable<A>, FA: Identity<TA>>(pure: Pure): FA {\n    return pure(this)\n  }\n}\n\nfunction constant<T, FT: Const<T>>(val: T): FT { return (new Const(val): any) }\nfunction applyConstant<T: Monoid, FT: ApplyConst<T>>(val: T): FT {\n  return (new ApplyConst(val): any)\n}\nfunction identity<T, FT: Identity<T>>(val: T): FT {\n  return (new Identity(val): any)\n}\n\ndeclare var compose: (<A,B,C,D,E>( fn3: (d: D) => E\n                                 , fn2: (c: C) => D\n                                 , fn1: (b: B) => C\n                                 , fn0: (a: A) => B\n                                 , $?: null\n                                 ) => (a: A) => E)\n                   & (<A,B,C,D>( fn2: (c: C) => D\n                               , fn1: (b: B) => C\n                               , fn0: (a: A) => B\n                               , $?: null\n                               ) => (a: A) => D)\n                   & (<A,B,C>( fn1: (b: B) => C\n                             , fn0: (a: A) => B\n                             , $?: null\n                             ) => (a: A) => C)\n                   & (<A,B>( fn0: (a: A) => B\n                           , $?: null\n                           ) => (a: A) => B)\n\n// Ordinary function composition - also works to compose lenses\nfunction compose(...functions) {\n  return functions.reduceRight((accum, fn) => x => fn(accum(x)))\n}\n\n/* lenses */\n\n/*\n * Creates a lens from a getter and setter function.\n */\nfunction lens<S,T,A,B>(\n  getter: (obj: S) => A,\n  setter: (obj: S, val: B) => T\n): Lens<S,T,A,B> {\n  return f => (pure, obj) => (\n    f(pure, getter(obj)).map(val => setter(obj, val))\n  )\n}\n\n\n/* getting */\n\n/*\n * Turns an ordinary function into a getter\n */\nfunction getter<S,A>(getter: (obj: S) => A): Getter<S,A> {\n  return f => (pure, obj) => (\n    f(pure, getter(obj)).map(_ => obj)\n  )\n}\n\n/*\n * Given a getter (which is a specialized lens), and data structure, gets\n * a value out of the data structure.\n */\nfunction get<S,A>(getter: Getting<A,S,A>, obj: S): A {\n  return getter((_, val) => new Const(val))(constant, obj).value\n}\n\n\n/* setting */\n\nfunction set<S,T,A,B>(setter: Setting<S,T,A,B>, val: B, obj: S): T {\n  return setter((_, __) => new Identity(val))(identity, obj).value\n}\n\nfunction over<S,T,A,B>(setter: Setting<S,T,A,B>, f: (val: A) => B, obj: S): T {\n  return setter((_, a) => new Identity(f(a)))(identity, obj).value\n}\n\n\n/* traversing */\n\nfunction traverseOf<S,T,A,B, FB: Apply<B>, FT: Apply<T>>\n  (pure: Pure, l: Traversal<S,T,A,B>, f: (p: Pure, _: A) => FB, obj: S): FT {\n  return l(f)(pure, obj)\n}\n\nfunction filtering<S>(predicate: (val: S) => boolean): Traversal_<S,S> {\n  return f => (pure, obj) => (\n    predicate(obj) ? f(pure, obj).map(id) : pure(obj)\n  )\n  // TODO: `.map(id)` suppresses a (hopefully unimportant) type error\n}\n\n\n/* folding */\n\n// `First` is one possible Monoid implementation for `Maybe`\nclass First<A> {\n  value: Maybe<A>;\n  constructor(value: Maybe<A>) { this.value = value }\n  concat<M: First<A>>(other: Monoid): M {\n    return ((this.value instanceof Just ? this : other): any)\n  }\n  empty<M: First<A>>(): M {\n    return (new First(nothing): any)\n  }\n}\nfunction first<A>(val: Maybe<A>): First<A> { return new First(val) }\n\nfunction foldMapOf<R:Monoid,S,A>(l: Fold<R,S,A>, f: (val: A) => R, mempty: R, obj: S): R {\n  var wrapConst = (pure, val) => applyConstant(f(val))\n  return l(wrapConst)(_ => applyConstant(mempty), obj).value\n}\n\n// `Endo` turns a function into a Monoid\nclass Endo<A> {\n  f: (_: A) => A;\n  constructor(f: (_: A) => A) { this.f = f }\n  concat<M: Endo<A>>(other: Monoid): M {\n    return (new Endo(compose(this.f, (other: any).f)): any)\n  }\n  empty<M: Endo<A>>(): M {\n    return (new Endo(id): any)\n  }\n}\nfunction endo<A>(f: (_: A) => A): Endo<A> { return new Endo(f) }\n\nfunction foldrOf<R,S,A>(\n  l: Fold<Endo<R>,S,A>, f: (val: A, accum: R) => R, init: R, obj: S\n): R {\n  var curried = val => accum => f(val, accum)\n  return foldMapOf(l, compose(endo, curried), new Endo(id), obj).f(init)\n}\n\nfunction sumOf<S>(l: Fold<Endo<number>,S,number>, obj: S): number {\n  return foldrOf(l, (x,y) => x+y, 0, obj)\n}\n\n/*\n * `lookup` is like `get`, except that the result might be `undefined`.\n *\n * `get` cannot be used with `Traversal` or `Fold` lenses.\n * In these cases, use `lookup` instead.\n *\n */\nfunction lookup<S,A>(l: Fold<First<A>,S,A>, obj: S): ?A {\n  function toMonoid<T>(val: T): First<T> { return first(just(val)) }\n  return foldMapOf(l, toMonoid, first(nothing), obj).value.value\n}\n\nfunction id<A>(val: A): A { return val }\n\nexport {\n  Endo,\n  Identity,\n  compose,\n  filtering,\n  foldMapOf,\n  foldrOf,\n  get,\n  getter,\n  getter as to,\n  id,\n  identity,\n  lens,\n  lookup,\n  over,\n  set,\n  sumOf,\n  traverseOf,\n}\n"]}